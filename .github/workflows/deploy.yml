name: Build Scan Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: dremer10/solar-system-simulator
  NAMESPACE: solar-system-prod
  HOSTNAME: solar.dremer10.com
  TLS_SECRET: solar-system-prod-tls

permissions:
  contents: write

jobs:
  build-scan-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determine next version tag
      id: version
      uses: actions/github-script@v7
      with:
        script: |
          const prefix = 'v1.0.';
          const tags = await github.paginate(github.rest.repos.listTags, {
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100,
          });
          const patches = tags
            .map(t => t.name)
            .filter(name => name.startsWith(prefix))
            .map(name => parseInt(name.replace(prefix, ''), 10))
            .filter(n => Number.isInteger(n));
          const next = patches.length ? Math.max(...patches) + 1 : 0;
          const tag = `${prefix}${next}`;
          core.setOutput('tag', tag);

    - name: Create git tag
      env:
        TAG: ${{ steps.version.outputs.tag }}
        GIT_AUTHOR_NAME: ${{ secrets.GIT_USER_NAME || github.actor }}
        GIT_AUTHOR_EMAIL: ${{ secrets.GIT_USER_EMAIL || format('{0}@users.noreply.github.com', github.actor_id) }}
      run: |
        if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
          echo "Tag ${TAG} already exists, skipping creation."
        else
          git config user.name "${GIT_AUTHOR_NAME}"
          git config user.email "${GIT_AUTHOR_EMAIL}"
          git tag "${TAG}"
          git push origin "${TAG}"
        fi

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.tag }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

    - name: Scan image for vulnerabilities
      uses: aquasecurity/trivy-action@0.24.0
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.tag }}
        format: table
        severity: CRITICAL,HIGH
        ignore-unfixed: true

    - name: Install kubectl
      uses: azure/setup-kubectl@v4

    - name: Set kubectl context
      uses: azure/k8s-set-context@v4
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.KUBECONFIG }}

    - name: Deploy to cluster
      env:
        IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.tag }}
        NAMESPACE: ${{ env.NAMESPACE }}
        HOSTNAME: ${{ env.HOSTNAME }}
        TLS_SECRET: ${{ env.TLS_SECRET }}
      run: |
        kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
        envsubst < k8s/solar-system-prod.yaml | kubectl apply -f -
        kubectl rollout status deployment/solar-system -n "${NAMESPACE}"
        kubectl get ingress -n "${NAMESPACE}"
