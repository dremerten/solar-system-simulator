name: Build Scan Deploy

on:
  push:
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: dremer10/solar-system-simulator

permissions:
  contents: write

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.meta.outputs.branch }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Install dependencies
      run: npm ci

    - name: Test (build smoke test)
      run: npm run build

    - name: Set branch output
      id: meta
      run: echo "branch=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

  push-prod:
    name: Push Production Image
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: build
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}
    env:
      GIT_AUTHOR_NAME: ${{ secrets.GIT_USER_NAME || github.actor }}
      GIT_AUTHOR_EMAIL: ${{ secrets.GIT_USER_EMAIL || format('{0}@users.noreply.github.com', github.actor_id) }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determine next version tag
      id: tag
      uses: actions/github-script@v7
      with:
        script: |
          const prefix = 'v1.0.';
          const tags = await github.paginate(github.rest.repos.listTags, {
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100,
          });
          const patches = tags
            .map(t => t.name)
            .filter(name => name.startsWith(prefix))
            .map(name => parseInt(name.replace(prefix, ''), 10))
            .filter(n => Number.isInteger(n));
          const next = patches.length ? Math.max(...patches) + 1 : 0;
          const tag = `${prefix}${next}`;
          core.setOutput('tag', tag);

    - name: Create git tag
      env:
        TAG: ${{ steps.tag.outputs.tag }}
      run: |
        if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
          echo "Tag ${TAG} already exists, skipping creation."
        else
          git config user.name "${GIT_AUTHOR_NAME}"
          git config user.email "${GIT_AUTHOR_EMAIL}"
          git tag "${TAG}"
          git push origin "${TAG}"
        fi

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.tag }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

  push-dev:
    name: Push Dev Image
    if: github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: build
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set image tag
      id: tag
      run: echo "image_tag=dev-${GITHUB_REF_NAME}-${GITHUB_RUN_NUMBER}" >> "$GITHUB_OUTPUT"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.image_tag }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-dev

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: build
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    - name: Install dependencies
      run: npm ci
    - name: Test (build smoke test)
      run: npm run build

  scan-prod:
    name: Scan Prod Image
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: push-prod
    env:
      IMAGE_TAG: ${{ needs.push-prod.outputs.image_tag }}
    steps:
    - name: Scan image (Trivy)
      uses: aquasecurity/trivy-action@0.24.0
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        format: table
        severity: CRITICAL,HIGH
        ignore-unfixed: true

  scan-dev:
    name: Scan Dev Image
    if: github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: push-dev
    env:
      IMAGE_TAG: ${{ needs.push-dev.outputs.image_tag }}
    steps:
    - name: Scan image (Trivy)
      uses: aquasecurity/trivy-action@0.24.0
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        format: table
        severity: CRITICAL,HIGH
        ignore-unfixed: true

  deploy-prod:
    name: Deploy Production
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [push-prod, scan-prod, test]
    env:
      IMAGE_TAG: ${{ needs.push-prod.outputs.image_tag }}
      NAMESPACE: solar-system-prod
      HOSTNAME: solar.dremer10.com
      TLS_SECRET: solar-system-prod-tls
    steps:
    - name: Install kubectl
      uses: azure/setup-kubectl@v4

    - name: Write kubeconfig
      env:
        KUBECONFIG_B64: ${{ secrets.KUBECONFIG }}
      run: |
        mkdir -p $HOME/.kube
        if [ -z "$KUBECONFIG_B64" ]; then
          echo "KUBECONFIG secret is empty"; exit 1
        fi
        if echo "$KUBECONFIG_B64" | base64 -d >/tmp/kubeconfig 2>/dev/null; then
          mv /tmp/kubeconfig $HOME/.kube/config
        else
          echo "KUBECONFIG is not valid base64. Please base64-encode your kubeconfig." >&2
          exit 1
        fi
        chmod 600 $HOME/.kube/config
        echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

    - name: Deploy to cluster
      env:
        IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        NAMESPACE: ${{ env.NAMESPACE }}
        HOSTNAME: ${{ env.HOSTNAME }}
        TLS_SECRET: ${{ env.TLS_SECRET }}
      run: |
        kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
        envsubst < k8s/solar-system-prod.yaml | kubectl apply -f -
        kubectl rollout status deployment/solar-system -n "${NAMESPACE}"
        kubectl get ingress -n "${NAMESPACE}"

  deploy-dev:
    name: Deploy Dev
    if: github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [push-dev, scan-dev, test]
    env:
      IMAGE_TAG: ${{ needs.push-dev.outputs.image_tag }}
      NAMESPACE: solar-dev
      HOSTNAME: solar-dev.dremer10.com
      TLS_SECRET: solar-dev-tls
    steps:
    - name: Install kubectl
      uses: azure/setup-kubectl@v4

    - name: Write kubeconfig
      env:
        KUBECONFIG_B64: ${{ secrets.KUBECONFIG }}
      run: |
        mkdir -p $HOME/.kube
        if [ -z "$KUBECONFIG_B64" ]; then
          echo "KUBECONFIG secret is empty"; exit 1
        fi
        if echo "$KUBECONFIG_B64" | base64 -d >/tmp/kubeconfig 2>/dev/null; then
          mv /tmp/kubeconfig $HOME/.kube/config
        else
          echo "KUBECONFIG is not valid base64. Please base64-encode your kubeconfig." >&2
          exit 1
        fi
        chmod 600 $HOME/.kube/config
        echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

    - name: Deploy to cluster
      env:
        IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        NAMESPACE: ${{ env.NAMESPACE }}
        HOSTNAME: ${{ env.HOSTNAME }}
        TLS_SECRET: ${{ env.TLS_SECRET }}
      run: |
        kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
        envsubst < k8s/solar-system-prod.yaml | kubectl apply -f -
        kubectl rollout status deployment/solar-system -n "${NAMESPACE}"
        kubectl get ingress -n "${NAMESPACE}"
